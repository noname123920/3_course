Задание 1. 

    Почему так происходит (простыми словами):

    Представьте, что числа типа int - это циферблат часов, который идет от -2147483648 до 2147483647.

    M + 1 = -2147483648 - это как если бы мы стояли на самой большой цифре (2147483647) и сделали еще один шаг вперед. Мы перескакиваем через край и оказываемся в самом начале - на самом маленьком отрицательном числе.

    2 * M = -2 - когда мы умножаем самое большое число на 2, мы делаем такой большой "скачок", что несколько раз оборачиваемся вокруг нашего "циферблата" и останавливаемся на числе -2.

    4. Техническая причина:
    Это называется целочисленное переполнение.  Каждый целочисленный тип (например, int, short, long, byte) имеет определённый минимальный и максимальный предел. Когда результат операции превышает эти пределы, происходит переполнение. 

    

    5. Важный вывод:
    Всегда нужно быть осторожным при работе с большими числами, чтобы не выйти за границы допустимого диапазона для выбранного типа данных.


Задание 2. 

    Что такое double?
    Double - это тип чисел с плавающей точкой (дробные числа), которые компьютер хранит с определенной точностью, как калькулятор.

    Что выводит программа:
    Min double (d) = 2.22507e-308

    Это самое маленькое положительное число, которое double может представить

    Это 0,000...000222507 (308 нулей после запятой!)

    Max double (D) = 1.79769e+308

    Это самое большое число, которое double может представить

    Это число с 308 цифрами! Огромное!

    Почему такие странные результаты?
    D + 1 == D: true
    Представьте, что у вас есть океан (D) и вы добавляете стакан воды (1)

    Разница не заметна! 1 слишком мала по сравнению с D

    Компьютер "не видит" эту разницу

    2 * D = inf
    inf = бесконечность (infinity)

    Если взять самое большое число и умножить на 2 - получится число, которое больше чем может представить компьютер

    Компьютер говорит: "Это бесконечность!"

    2*D - D = inf
    Бесконечность минус огромное число = всё равно бесконечность

    Как если из бесконечности вычесть миллиард - всё равно бесконечность

    2*D - 2*D = nan
    nan = "не число" (not a number)

    Бесконечность минус бесконечность - это математическая неопределенность

    Компьютер не может это посчитать

    2*D - 3*D = -inf
    Бесконечность минус большая бесконечность = отрицательная бесконечность

    Если представить числовую прямую: от очень большого положительного числа отнимаем ещё большее - уходим в минус

    Вывод:
    Компьютер работает с числами по строгим математическим правилам (стандарт IEEE 754). Когда числа становятся слишком большими или слишком маленькими, он использует специальные значения:

    inf - бесконечность

    nan - не число

    Очень маленькие числа могут "теряться" при операциях с очень большими

    Это не ошибка, а особенность работы с числами в компьютере! 

Задание 3. 
    
    Что такое машинное эпсилон (ε)?
    Машинное эпсилон - это самое маленькое число такое, что когда мы прибавляем его к 1, результат становится больше 1.

    Представьте, что у компьютера есть "микроскоп" для чисел. Эпсилон - это самый маленький объект, который этот микроскоп может разглядеть рядом с числом 1.

    Что выводит программа:
    Машинное эпсилон для double (ε): 2.22045e-16

    Это 0,000000000000000222045 (16 нулей после запятой!)

    Очень-очень маленькое число!

    Почему такие результаты?
    1 + ε == 1: false
    Компьютер МОЖЕТ увидеть разницу между 1 и (1 + ε)

    ε достаточно большое, чтобы "микроскоп" компьютера заметил изменение

    Как если положить песчинку на весы - весы покажут разницу

    1 + 0.5 * ε == 1: true
    Компьютер НЕ МОЖЕТ увидеть разницу между 1 и (1 + 0.5ε)

    0.5ε в два раза меньше ε - слишком маленькое!

    "Микроскоп" компьютера не может это разглядеть

    Как если положить полпесчинки на весы - весы не заметят разницы

    Простая аналогия:
    Представьте, что у вас есть линейка с делениями только до миллиметров:

    ε = 1 мм (самое маленькое деление)

    1 + ε = 1 см 1 мм - видно разницу! 

    1 + 0.5ε = 1 см 0.5 мм - линейка не показывает полмиллиметра! 

    Важный вывод:
    Компьютер работает с числами с ограниченной точностью. Он не может представлять все числа идеально точно. Машинное эпсилон показывает предел точности для чисел типа double.

    Это объясняет, почему иногда в вычислениях с плавающей точкой возникают маленькие погрешности!

Задание 4.

    